#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.13
# In conjunction with Tcl version 8.6
#    May 10, 2018 05:49:23 AM
#    May 10, 2018 06:40:48 PM
#    May 10, 2018 07:43:01 PM
#    May 10, 2018 07:55:14 PM
#    May 10, 2018 09:33:27 PM
#    May 13, 2018 01:56:43 AM
#    May 13, 2018 11:58:30 PM
#    May 19, 2018 04:09:05 AM


import sys

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = False

except ImportError:
    import tkinter.ttk as ttk
    py3 = True

import threading, time, base4
        
from tkinter import filedialog

#Para usar OpenGL
from OpenGL.GLUT import *
from OpenGL.GL import *
from OpenGL.GLU import *


def set_Tk_var():
    global stepCounter
    global finalizar
    global parar
    global spinbox
    spinbox = StringVar()
    global population
    population = StringVar()
    global intervalo
    #global candado
    stepCounter = StringVar()
    finalizar=StringVar()
    parar=StringVar()
    intervalo=StringVar()
    global energy
    energy=StringVar()
    global HEnergy
    HEnergy=IntVar()

def Forzar_Cierre():
    print('EDCA_support.Forzar_Cierre')
    w.Frame1.pack_forget()
    sys.stdout.flush()

def snapShot():
    fd=filedialog
    fichero=fd.asksaveasfilename(defaultextension=".matrix",filetypes=[("Matrix", "*.matrix")]) 
    f = open(fichero, 'w')
    #Save cells
    f.write("Celdas\n")
    b=lattice.grid
    for k,cell in b.items():
        y,x=k
        xr=(x*6.0/1000.0+mo.dx)*mo.sc
        yr=(y*6.0/1000.0+mo.dy)*mo.sc
        if -1<xr<1 and -1<yr<1:
            f.write(str(x)+" "+str(y)+" "+"\n")  
            f.write("\n")
    #Save field
    f.write("Fields\n")
    b=lattice.campo
    for k,valor in b.items():
        y,x=k
        xr=(x*6.0/1000.0+mo.dx)*mo.sc
        yr=(y*6.0/1000.0+mo.dy)*mo.sc
        if -1<xr<1 and -1<yr<1:
            f.write(str(x)+" "+str(y)+" "+str(round(valor,2))+" "+"\n")  
            f.write("\n")
    f.close()
    print("Crea snapshot")
    sys.stdout.flush()
    
def CambioEscala(p1):
    print('EDCA_support.CambioEscala')
    sys.stdout.flush()

def salvaModelo():
    fd=filedialog
    fichero=fd.asksaveasfilename(defaultextension=".exx",filetypes=[("Energy", "*.exx")])
    gauges.outputData(fichero)
    print('EDCA_support.salvaModelo')
    sys.stdout.flush()

def startModel(p1):
    parar.set("0")
    print('EDCA_support.startModel')
    sys.stdout.flush()

def stopModel(p1):
    #candado.acquire()
    parar.set("1")
    print('EDCA_support.stopModel')
    sys.stdout.flush()

def abrir_file():
    global ruleList,lattice,quanta,gauges,mo,timed,fichero
    fd=filedialog
    fichero=fd.askopenfilename(defaultextension=".mex",filetypes=[("Edca model", "*.mex")])
    print(fichero)
    lattice=base4.CellSpace()
    ruleList=base4.rules()
    quanta=base4.qSpace()
    gauges=base4.SensorSpace()
    timed={} #Almacena los objetos que se activan pasados tp pasos
    base4.abrir(fichero,ruleList,lattice,quanta,gauges,timed)
    stepCounter.set("0")
    parar.set("1")
    intervalo.set("0.01")
    try:
        if mo.isAlive:
            mo.setInitialState()
            print("Alive")
            finalizar.set("1")
    except NameError:
        mo = mainOpenGL()
        mo.start()
    sys.stdout.flush()



class GaugeReport:
    def __init__(self):
        self.headers=[]
        self.data=[]

class mainOpenGL(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self,daemon=True)
        self.mouseIniX,self.mouseIniY,self.mouseX,self.mouseY,self.mouseAbajo,self.mouseRight=0.0,0.0,0.0,0.0,0,0
        self.xinit,self.yinit=-1.0,-1.0
        self.xfinal,self.yfinal=1.0,1.0
        self.sc=1.0
        self.dx=0
        self.dy=0
    def setInitialState(self):  
        self.mouseIniX,self.mouseIniY,self.mouseX,self.mouseY,self.mouseAbajo,self.mouseRight=0.0,0.0,0.0,0.0,0,0
        self.xinit,self.yinit=-1.0,-1.0
        self.xfinal,self.yfinal=1.0,1.0
        self.sc=1.0
        self.dx=0
        self.dy=0
        
    def mouse(self,button, state, x, y):
        global mouseAbajo,mouseIniX,mouseIniY,mouseX,mouseY, mouseRight
        if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:
            self.mouseIniX=self.mouseX=x
            self.mouseIniY=self.mouseY=y
            self.mouseAbajo=1
        if button == GLUT_LEFT_BUTTON and state == GLUT_UP:
            self.mouseIniX=self.mouseX=x
            self.mouseIniY=self.mouseY=y
            self.mouseAbajo=0
        if button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:
            self.mouseIniX=self.mouseX=x
            self.mouseIniY=self.mouseY=y
            self.mouseRight=1
        if button == GLUT_RIGHT_BUTTON and state == GLUT_UP:
            self.mouseIniX=self.mouseX=x
            self.mouseIniY=self.mouseY=y
            self.mouseRight=0
            
    def mousemotion(self,x,y):
        self.mouseX = x
        self.mouseY = y
        if self.mouseAbajo: #Mover los puntos
            self.dx+=(self.mouseX-self.mouseIniX)/1000.0
            self.dy+=(self.mouseIniY-self.mouseY)/1000.0
            glTranslate((self.mouseX-self.mouseIniX)/1000.0,(self.mouseIniY-self.mouseY)/1000.0,0)
            print(self.dx,self.dy)
        if self.mouseRight: # Escalar los puntos
            escala=1.0
            if self.mouseIniY-self.mouseY>0:
                escala=1.01
            elif self.mouseIniY-self.mouseY<0:
                escala=0.99
            glScalef(escala,escala,1.0)
            glTranslate((escala-1)*(self.dx),(escala-1)*(self.dy),0)
            self.sc*=escala
            spinbox.set(round(self.sc,2))
        self.mouseIniX=self.mouseX=x
        self.mouseIniY=self.mouseY=y

    def initGraphic(self):
        glClearColor(0.0, 0.0, 0.0, 1.0)
        gluOrtho2D(self.xinit, self.xfinal, self.yinit, self.yfinal)
        #glRotatef(90.0, 0.0, 0.0, 1.0)
    def punto(self,y,x,s): # x y y intercambiadas para tener x-vertical, y-horizontal
        x=6*x
        y=6*y
        glVertex2f(s*float(x-2)/1000.0, s*float(y-2)/1000.0)
        glVertex2f(s*float(x-2)/1000.0, s*float(y+2)/1000.0)
        glVertex2f(s*float(x+2)/1000.0, s*float(y+2)/1000.0)
        glVertex2f(s*float(x+2)/1000.0, s*float(y-2)/1000.0)  
    
    def plotG(self,g):
        y=float(g[0])*6.0/1000.0
        x=float(g[1])*6.0/1000.0
        glColor4f(0.0, 0.0, 1.0, 1.0)
        glPointSize(10)
        glBegin(GL_POINTS)
        #print(g)
        glVertex2f(x,y)  
        glEnd()

    def plotSpot(self,spot):
        y,x=spot.origen
        if spot.valor==1:
            glColor4f(0.0, 1.0, 0.0, 0.3) #Spot positivo verde, transparencia 0.3
        else:
            glColor4f(1.0, 0.0, 0.0, 0.3) #Spot negativo rojo, transparencia 0.3
        span=spot.r1+(spot.longevity+1)*spot.r0
        x1=x2=float(x-span)*0.001*6
        x3=x4=float(x+span)*0.001*6
        y1=y4=float(y-span)*0.001*6
        y2=y3=float(y+span)*0.001*6
        glVertex2f(x1,y1)
        glVertex2f(x2,y2)
        glVertex2f(x3,y3)
        glVertex2f(x4,y4)

    def displaySpots(self):
        glPolygonMode(GL_FRONT, GL_LINE)
        glPolygonMode(GL_BACK, GL_LINE)
        glBegin(GL_QUADS)
        for spot in quanta.quanta:
            self.plotSpot(spot)
        glEnd()

    def plotpoints(self):
        #Realiza un step del CA y visualiza cada frame correspondiente
        #actualizando todo los objetos en pantalla
        population.set(str(len(lattice.grid)))
        energy.set(len(quanta.quanta))        
        if not finalizar.get()=="1":
            if parar.get()=="0":
                stepCounter.set(str(int(stepCounter.get())+1))
                tiempo=time.time()
                paso=int(stepCounter.get())
                base4.doStep(lattice,quanta,ruleList,gauges,timed,paso)
                pausa=float(intervalo.get())
                while time.time()-tiempo<pausa: pass #controla la velocidad
            glClear(GL_COLOR_BUFFER_BIT)
            glColor4f(1.0, 1.0, 1.0, 0.7) #Celdas vivas color blanco
            glPolygonMode(GL_FRONT, GL_FILL)
            glPolygonMode(GL_BACK, GL_FILL)
            glBegin(GL_QUADS)
            s=self.sc
            for k,v in lattice.grid.items(): 
                x,y=k
                self.punto(x,y,1.0)
            glEnd()
            #Display Spots
            if not HEnergy.get(): self.displaySpots()
            if lattice.gForce>0:
                self.plotG(lattice.gCenter)
            
            glFlush()
        else:
            self.setInitialState()
            glPopMatrix()
            finalizar.set("0")
            glPushMatrix()

    def display(self):
        pass
        
    def run(self):
        glutInit(sys.argv)
        glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB)
        glutInitWindowSize(800,800)
        glutInitWindowPosition(50,50)
        glutCreateWindow("Running EDCA...")
        glutDisplayFunc(self.display)
        glutIdleFunc(self.plotpoints)
        glutMotionFunc(self.mousemotion)
        glutMouseFunc(self.mouse)
        self.initGraphic()
        #Habilitar Transparencia---------------------------
        glEnable (GL_BLEND)
        glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        #--------------------------------------------------
        glPushMatrix()
        glutMainLoop()

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    stepCounter.set(1)
    spinbox.set(1)
    intervalo.set("0.01")
    population.set("0")
    energy.set("0")
    HEnergy.set(0)

def destroy_window():
    # Function which closes the window.
    #finalizar.set("1")
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import EDCA
    EDCA.vp_start_gui()





























