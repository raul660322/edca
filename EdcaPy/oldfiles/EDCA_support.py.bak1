#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.13
# In conjunction with Tcl version 8.6
#    May 10, 2018 05:49:23 AM
#    May 10, 2018 06:40:48 PM
#    May 10, 2018 07:43:01 PM
#    May 10, 2018 07:55:14 PM
#    May 10, 2018 09:33:27 PM
#    May 13, 2018 01:56:43 AM
#    May 13, 2018 11:58:30 PM


import sys

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = False

except ImportError:
    import tkinter.ttk as ttk
    py3 = True

import threading, time, base4
        
from tkinter import filedialog

#Para usar OpenGL
from OpenGL.GLUT import *
from OpenGL.GL import *
from OpenGL.GLU import *


def set_Tk_var():
    global stepCounter
    global finalizar
    global parar
    global spinbox
    spinbox = StringVar()
    global intervalo
    #global candado
    stepCounter = StringVar()
    finalizar=StringVar()
    parar=StringVar()
    intervalo=StringVar()

def Forzar_Cierre():
    print('EDCA_support.Forzar_Cierre')
    w.Frame1.pack_forget()
    sys.stdout.flush()
    
def CambioEscala(p1):
    print('EDCA_support.CambioEscala')
    sys.stdout.flush()

def salvaModelo(p1):
    print('EDCA_support.salvaModelo')
    sys.stdout.flush()

def startModel(p1):
    parar.set("0")
    print('EDCA_support.startModel')
    sys.stdout.flush()

def stopModel(p1):
    #candado.acquire()
    parar.set("1")
    print('EDCA_support.stopModel')
    sys.stdout.flush()

def abrir_file():
    global ruleList,lattice,quanta, mo
    fd=filedialog
    fichero=fd.askopenfilename(defaultextension=".mex",filetypes=[("Edca model", "*.mex")])
    print(fichero)
    lattice=base4.CellSpace()
    ruleList=base4.rules()
    quanta=base4.qSpace()
    base4.abrir(fichero,ruleList,lattice,quanta)
    stepCounter.set("0")
    parar.set("1")
    intervalo.set("0.01")
    try:
        if mo.isAlive:
            mo.setInitialState()
            print("Alive")
            finalizar.set("1")
    except NameError:
        mo = mainOpenGL()
        mo.start()

    w.Canvas1.delete("A")
    for k,v in lattice.grid.items(): 
        #print(k,v.valor)
        x,y=k
        cid=w.Canvas1.create_rectangle(4*int(x),4*int(y),4*(int(x)+1),4*(int(y)+1))
        w.Canvas1.addtag_withtag("A", cid)

    sys.stdout.flush()


class mainOpenGL(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self,daemon=True)
        self.mouseIniX,self.mouseIniY,self.mouseX,self.mouseY,self.mouseAbajo,self.mouseRight=0.0,0.0,0.0,0.0,0,0
        self.xinit,self.yinit=0.0,0.0
        self.xfinal,self.yfinal=1.0,1.0
        self.sc=5.0
        self.dx=0
        self.dy=0
    def setInitialState(self):  
        self.mouseIniX,self.mouseIniY,self.mouseX,self.mouseY,self.mouseAbajo,self.mouseRight=0.0,0.0,0.0,0.0,0,0
        self.xinit,self.yinit=0.0,0.0
        self.xfinal,self.yfinal=1.0,1.0
        self.sc=5.0
        self.dx=0
        self.dy=0
        
    def mouse(self,button, state, x, y):
        global mouseAbajo,mouseIniX,mouseIniY,mouseX,mouseY, mouseRight
        if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:
            self.mouseIniX=self.mouseX=x
            self.mouseIniY=self.mouseY=y
            self.mouseAbajo=1
        if button == GLUT_LEFT_BUTTON and state == GLUT_UP:
            self.mouseIniX=self.mouseX=x
            self.mouseIniY=self.mouseY=y
            self.mouseAbajo=0
        if button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:
            self.mouseIniX=self.mouseX=x
            self.mouseIniY=self.mouseY=y
            self.mouseRight=1
        if button == GLUT_RIGHT_BUTTON and state == GLUT_UP:
            self.mouseIniX=self.mouseX=x
            self.mouseIniY=self.mouseY=y
            self.mouseRight=0
            
    def mousemotion(self,x,y):
        self.mouseX = x
        self.mouseY = y
        if self.mouseAbajo: 
            self.dx=(self.mouseX-self.mouseIniX)/100.0
            self.dy=(self.mouseIniY-self.mouseY)/100.0
            glTranslate((self.mouseX-self.mouseIniX)/1000.0,(self.mouseIniY-self.mouseY)/1000.0,0)
            print(self.dx,self.dy)
        if self.mouseRight:
            #xfinal+=(mouseX-mouseIniX)/1000.0
            #self.yfinal+=(self.mouseIniY-self.mouseY)
            #gluOrtho2D(xinit, xfinal, yinit, yfinal)
            #glutPostRedisplay()
            self.sc+=(self.mouseIniY-self.mouseY)*0.1
            glTranslate((self.mouseIniY-self.mouseY)*(self.dx-0.01),(self.mouseIniY-self.mouseY)*(self.dy-0.01),0)
            #glTranslate(-(self.mouseIniY-self.mouseY)*0.01,-(self.mouseIniY-self.mouseY)*0.01,0)
            spinbox.set(int(self.sc))
        self.mouseIniX=self.mouseX=x
        self.mouseIniY=self.mouseY=y

    def initGraphic(self):
        glClearColor(0.0, 0.0, 0.0, 1.0)
        gluOrtho2D(self.xinit, self.xfinal, self.yinit, self.yfinal)
        
    def plotpoints(self):
        
        #global candado
        #candado.acquire()
        b=quanta.quanta
        if not finalizar.get()=="1":
            #if finalizar.get()=="1":return
            #candado.acquire()
            #candado.release()
            
            if parar.get()=="0":
                tiempo=time.time()
                stepCounter.set(str(int(stepCounter.get())+1))
                #Inicio de un step del CA
                lattice.newBornCandidates()
                for k in b:
                    k.procesarCeldas1(lattice,ruleList)
                lattice.actualiza()
                #Fin del step
                pausa=float(intervalo.get())
                while time.time()-tiempo<pausa: pass
                #print(time.process_time()-tiempo)
                #time.sleep(intervalo)
            glClear(GL_COLOR_BUFFER_BIT)
            glColor3f(1.0, 1.0, 1.0)
            #print(self.mouseAbajo,self.mouseIniX,self.mouseX,self.mouseIniY,self.mouseY)
            #if mouseAbajo: glTranslate((mouseX-mouseIniX)/1000.0,(mouseY-mouseIniY)/1000.0,0)
            glBegin(GL_QUADS)
            #self.sc=float(spinbox.get())
            s=self.sc
            for k,v in lattice.grid.items(): 
                x,y=k
                #glVertex2f(float(x)/1000.0, float(y)/1000.0)
                glVertex2f(s*float(x)/1000.0, s*float(y)/1000.0)
                glVertex2f(s*float(x)/1000.0, s*float(y+1)/1000.0)
                glVertex2f(s*float(x+1)/1000.0, s*float(y+1)/1000.0)
                glVertex2f(s*float(x+1)/1000.0, s*float(y)/1000.0)
            glEnd()
            glFlush()
        else:
            self.setInitialState()
            glPopMatrix()
            finalizar.set("0")
            glPushMatrix()
            #self._stop
            #self._delete
        #candado.release()
    def display(self):
        pass
    def run(self):
        glutInit(sys.argv)
        glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB)
        glutInitWindowSize(800,800)
        glutInitWindowPosition(50,50)
        glutCreateWindow("Running EDCA...")
        glutDisplayFunc(self.display)
        glutIdleFunc(self.plotpoints)
        glutMotionFunc(self.mousemotion)
        glutMouseFunc(self.mouse)
        self.initGraphic()
        glPushMatrix()
        glutMainLoop()

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    stepCounter.set(1)
    spinbox.set(3)
    intervalo.set("0.01")
    #w.Frame1.grid_forget()
    #w.Button4.grid_forget()
    #candado=threading.Lock()

def destroy_window():
    # Function which closes the window.
    #finalizar.set("1")
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import EDCA
    EDCA.vp_start_gui()
























